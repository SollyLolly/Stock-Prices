# -*- coding: utf-8 -*-
"""Final Descriptive Analysis codes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/112BpNnC3PagXIlwQPD04Z4Em9K71GtsP
"""

# Commented out IPython magic to ensure Python compatibility.
# For Data Processing
import numpy as np
import pandas as pd
from pandas import Series, DataFrame
# Data Visualization
import matplotlib.pyplot as plt
import seaborn as sns
plt.style.use('seaborn')
sns.set_style('whitegrid')
# %matplotlib inline
# For reading stock data from yahoo
from pandas_datareader import DataReader
# For time stamps
from datetime import datetime
# For division
from __future__ import division
#For data source
!pip install yfinance
import yfinance as yf
from scipy.stats import skew,kurtosis,norm,skewtest,kurtosistest
from statsmodels.graphics.tsaplots import plot_pacf,plot_acf
sns.set_style('whitegrid')
plt.style.use('ggplot')

# Download closing prices of MSFT, GOOGL, TLW.L, TSLA
data = yf.download("MSFT GOOGL TLW.L TSLA", start="2019-03-15", end="2022-03-15")['Close'].reset_index()
#data = yf.download("MSFT GOOGL TLW.L TSLA", start="2021-03-15", end="2022-03-15")
data.head()

data.info()

"""Daily Return Analysis"""

GOOGL=data['GOOGL'].fillna(method='bfill')
MSFT=data['MSFT'].fillna(method='bfill')
TLW=data['TLW.L'].fillna(method='bfill')
TSLA=data['TSLA'].fillna(method='bfill')

data_GOOGL_return = data['GOOGL_DailyChange']=GOOGL.pct_change(1).fillna(0)
data_MSFT_return = data['MSFT_DailyChange']=MSFT.pct_change(1).fillna(0)
data_TLW_return = data['TLW_DailyChange']=TLW.pct_change(1).fillna(0)
data_TSLA_return = data['TSLA_DailyChange']=TSLA.pct_change(1).fillna(0)

"""**The probability distribution of returns**

We are now going to calculate some insights about the probability distribution of returns.

**Histogram and boxplot **

Letâ€™s make a first raw histogram of returns.

The return from one day to another one is the percentage change of the closing price between the two days.
"""

#density=True keeps the same property (area under curve sums to 1) and is more meaningful and useful.

plt.hist(data_GOOGL_return,bins="rice", label="GOOGLE")
plt.xlabel("Daily returns (% change)") 
plt.ylabel("Count")
mu, std = norm.fit(data_GOOGL_return)
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = norm.pdf(x, mu, std)
plt.plot(x, p, 'k', linewidth = 2)
plt.legend()
plt.show()

plt.hist(data_TSLA_return,bins="rice", label="TSLA")
plt.xlabel("Daily returns (% change)") 
plt.ylabel("Count")
mu, std = norm.fit(data_TSLA_return)
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = norm.pdf(x, mu, std)
plt.plot(x, p, 'k', linewidth = 2)
plt.legend()
plt.show()

plt.hist(data_MSFT_return,bins="rice", label="MSFT")
plt.xlabel("Daily returns (% change)") 
plt.ylabel("Count")
mu, std = norm.fit(data_MSFT_return)
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = norm.pdf(x, mu, std)
plt.plot(x, p, 'k', linewidth = 2)
plt.legend()
plt.show()

plt.hist(data_TLW_return,bins="rice", label="TLW")
plt.xlabel("Daily returns (% change)") 
plt.ylabel("Count")
mu, std = norm.fit(data_TLW_return)
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 200)
p = norm.pdf(x, mu, std)
plt.plot(x, p, 'k', linewidth = 2)
plt.legend()
plt.show()

data_Ret = pd.DataFrame({'GOOGL':data_GOOGL_return,'MSFT': data_MSFT_return,'TLW': data_TLW_return,'TSLA': data_TSLA_return,})
data_Ret.boxplot(figsize=(8,8));
plt.title('Comparison of Daily Returns')
plt.style.use('fivethirtyeight')
plt.show()

"""Main observables

Calculating some observables of the dataset.
"""

print('                            GOOGLE                 MICROSOFT              TULLOW OIL PLC                TESLA')
print('Mean', '              |', np.mean(data_GOOGL_return),' |', np.mean(data_MSFT_return),'|', np.mean(data_TLW_return), ' |',np.mean(data_TSLA_return),'|',)
print('Standard Deviation', '|', np.std(data_GOOGL_return),' |', np.std(data_MSFT_return),' |', np.std(data_TLW_return), '   |', np.std(data_TSLA_return),' |',)
print('Median', '            |', np.quantile(data_GOOGL_return, 0.5),' |', np.quantile(data_MSFT_return, 0.5),'|', np.quantile(data_TLW_return, 0.5), '|',np.quantile(data_TSLA_return, 0.5),' |',)
print('Skew', '              |', skew(data_GOOGL_return),'|', skew(data_MSFT_return),' |', skew(data_TLW_return), '   |', skew(data_TSLA_return),'  |',)
print('Kurtosis', '          |', kurtosis(data_GOOGL_return),'    |', kurtosis(data_MSFT_return),'   |', kurtosis(data_TLW_return), '    |', kurtosis(data_TSLA_return),'    |',)

print('                                        SKEW TEST                                                                       KURTOSIS TEST')
print('GOOG',' |', skewtest(data_GOOGL_return),'  |', kurtosistest(data_GOOGL_return),'  |')
print('MSFT',' |', skewtest(data_MSFT_return),'   |', kurtosistest(data_MSFT_return),'|')
print('TLW','  |', skewtest(data_TLW_return),'|', kurtosistest(data_TLW_return),' |')
print('TSLA',' |', skewtest(data_TSLA_return),'   |', kurtosistest(data_TSLA_return),'  |')

print('GOOG',' |', skewtest(data_GOOGL_return),'      |','\n' '      |', kurtosistest(data_GOOGL_return),'  |')
print('      |                                                                                 |')
print('MSFT',' |', skewtest(data_MSFT_return),'       |',  '\n''      |', kurtosistest(data_MSFT_return),'|')
print('      |                                                                                 |')
print('TLW','  |', skewtest(data_TLW_return),'    |','\n''      |', kurtosistest(data_TLW_return),' |')
print('      |                                                                                 | ')
print('TSLA',' |', skewtest(data_TSLA_return),'       |',' \n''      |', kurtosistest(data_TSLA_return),'  |')

# Q-Q Plot:

t = np.linspace(0.01,0.99,1000)
q1 = np.quantile(data_GOOGL_return,t)
q2 = norm.ppf(t,loc=np.mean(data_GOOGL_return),scale=np.std(data_GOOGL_return))
plt.plot(q1,q2)
plt.plot([min(q1),max(q1)],[min(q2),max(q2)])
plt.xlim((min(q1),max(q1)))
plt.ylim((min(q2),max(q2)))
plt.xlabel("GOOGLE Daily returns")
plt.ylabel("Normal distribution")
plt.show()

t = np.linspace(0.01,0.99,1000)
q1 = np.quantile(data_MSFT_return,t)
q2 = norm.ppf(t,loc=np.mean(data_MSFT_return),scale=np.std(data_MSFT_return))
plt.plot(q1,q2)
plt.plot([min(q1),max(q1)],[min(q2),max(q2)])
plt.xlim((min(q1),max(q1)))
plt.ylim((min(q2),max(q2)))
plt.xlabel("MSFT Daily returns")
plt.ylabel("Normal distribution")
plt.show()

t = np.linspace(0.01,0.99,1000)
q1 = np.quantile(data_TSLA_return,t)
q2 = norm.ppf(t,loc=np.mean(data_TSLA_return),scale=np.std(data_TSLA_return))
plt.plot(q1,q2)
plt.plot([min(q1),max(q1)],[min(q2),max(q2)])
plt.xlim((min(q1),max(q1)))
plt.ylim((min(q2),max(q2)))
plt.xlabel("TSLA Daily returns")
plt.ylabel("Normal distribution")
plt.show()

t = np.linspace(0.01,0.99,1000)
q1 = np.quantile(data_GOOGL_return,t)
q2 = norm.ppf(t,loc=np.mean(data_TLW_return),scale=np.std(data_TLW_return))
plt.plot(q1,q2)
plt.plot([min(q1),max(q1)],[min(q2),max(q2)])
plt.xlim((min(q1),max(q1)))
plt.ylim((min(q2),max(q2)))
plt.xlabel("TLW Daily returns")
plt.ylabel("Normal distribution")
plt.show()

#Volatility Analysis
GOOGL=data['GOOGL'].fillna(method='bfill')
MSFT=data['MSFT'].fillna(method='bfill')
TLW=data['TLW.L'].fillna(method='bfill')
TSLA=data['TSLA'].fillna(method='bfill')

data['GOOGL_DailyChange']=GOOGL.pct_change(1).fillna(0)
data['MSFT_DailyChange']=MSFT.pct_change(1).fillna(0)
data['TLW_DailyChange']=TLW.pct_change(1).fillna(0)
data['TSLA_DailyChange']=TSLA.pct_change(1).fillna(0)

data_vol_GOOGL = data['GOOGL_DailyChange'].rolling(2).std().fillna(0)
data_vol_MSFT = data['MSFT_DailyChange'].rolling(2).std().fillna(0)
data_vol_TLW = data['TLW_DailyChange'].rolling(2).std().fillna(0)
data_vol_TSLA = data['TSLA_DailyChange'].rolling(2).std().fillna(0)

from IPython.core.pylabtools import figsize
fig, ax = plt.subplots(2,2,figsize=(15,8))

# GOOGL
ax[0,0].plot(data['Date'],data_vol_GOOGL)
ax[0,0].set_xlabel('Month')
ax[0,0].tick_params(axis="x", rotation=45)
ax[0,0].set_ylabel('2-days rolling standard deviation')
ax[0,0].set_title('Daily Volatility of GOOGL')

# MSFT
ax[0,1].plot(data['Date'],data_vol_MSFT)
ax[0,1].set_xlabel('Month')
ax[0,1].tick_params(axis="x", rotation=45)
ax[0,1].set_ylabel('2-days rolling standard deviation')
ax[0,1].set_title('Daily Volatility of MSFT')

# TLW.L
ax[1,0].plot(data['Date'],data_vol_TLW)
ax[1,0].set_xlabel('Month')
ax[1,0].tick_params(axis="x", rotation=45)
ax[1,0].set_ylabel('2-days rolling standard deviation')
ax[1,0].set_title('Daily Volatility of TLW.L')

# TSLA
ax[1,1].plot(data['Date'],data_vol_TSLA)
ax[1,1].set_xlabel('Month')
ax[1,1].tick_params(axis="x", rotation=45)
ax[1,1].set_ylabel('2-days rolling standard deviation')
ax[1,1].set_title('Daily Volatility of TSLA')

plt.subplots_adjust(top=2)
plt.show()

data_vol = pd.DataFrame({'GOOGL':data_vol_GOOGL,'MSFT': data_vol_MSFT,'TLW': data_vol_TLW,'TSLA': data_vol_TSLA,})
data_vol.boxplot(figsize=(10,6));
plt.title('Comparison of Daily Volatility')
plt.show()

#Correlation between closing prices of each stock
data_corr_price = pd.DataFrame({'GOOGL':data['GOOGL'], 'MSFT':data['MSFT'],'TLW':data['TLW.L'],'TSLA':data['TSLA']})
sns.heatmap(data_corr_price.corr(),cmap='coolwarm',annot=True);

#Correlation between daily returns of each stock
data_corr_DailyReturn = pd.DataFrame({'GOOGL':data['GOOGL_DailyChange'], 'MSFT':data['MSFT_DailyChange'],'TLW':data['TLW_DailyChange'],'TSLA':data['TSLA_DailyChange']})
sns.heatmap(data_corr_DailyReturn.corr(),cmap='coolwarm',annot=True);

#Correlation between volatility of daily returns of each stock
data_corr_vol = pd.DataFrame({'GOOGL':data_vol_GOOGL, 'MSFT':data_vol_MSFT,'TLW':data_vol_TLW,'TSLA':data_vol_TSLA})
sns.heatmap(data_corr_vol.corr(),cmap='coolwarm',annot=True);

#Autocorrelation on daily closing prices

# GOOGL
plot_acf(GOOGL, lags=20)
plt.title('Autocorrelation of GOOGL on Daily Closing Price')
plt.show()

#MSFT
plot_acf(MSFT, lags=20)
plt.title('Autocorrelation of MSFT on Daily Closing Price')
plt.show()

#TLW.L
plot_acf(TLW, lags=20)
plt.title('Autocorrelation of TLW on Daily Closing Price')
plt.show()

#TSLA
plot_acf(TSLA, lags=20)
plt.title('Autocorrelation of TSLA on Daily Closing Price')
plt.show()

#Partial Autocorrelation on daily closing prices

# GOOGL
pd.plotting.autocorrelation_plot(GOOGL)
plt.title('Partial Autocorrelation of GOOGL on Daily Closing Price')
plt.show()

# MSFT
pd.plotting.autocorrelation_plot(MSFT)
plt.title('Partial Autocorrelation of MSFT on Daily Closing Price')
plt.show()

# TLW.L
pd.plotting.autocorrelation_plot(TLW)
plt.title('Partial Autocorrelation of TLW on Daily Closing Price')
plt.show()

# TSLA
pd.plotting.autocorrelation_plot(TSLA)
plt.title('Partial Autocorrelation of TSLA on Daily Closing Price')
plt.show()

#Autocorrelation on daily return

# GOOGL
plot_acf(data['GOOGL_DailyChange'], lags=20)
plt.title('Autocorrelation of GOOGL on Daily Return')
plt.show()

#MSFT
plot_acf(data['MSFT_DailyChange'], lags=20)
plt.title('Autocorrelation of MSFT on Daily Return')
plt.show()

#TLW.L
plot_acf(data['TLW_DailyChange'], lags=20)
plt.title('Autocorrelation of TLW on Daily Return')
plt.show()

#TSLA
plot_acf(data['TSLA_DailyChange'], lags=20)
plt.title('Autocorrelation of TSLA on Daily Return')
plt.show()

#Partial Autocorrelation on daily return

# GOOGL
pd.plotting.autocorrelation_plot(data['GOOGL_DailyChange'])
plt.title('Partial Autocorrelation of GOOGL on Daily Return')
plt.show()

# MSFT
pd.plotting.autocorrelation_plot(data['MSFT_DailyChange'])
plt.title('Partial Autocorrelation of MSFT on Daily Return')
plt.show()

# TLW.L
pd.plotting.autocorrelation_plot(data['TLW_DailyChange'])
plt.title('Partial Autocorrelation of TLW on Daily Return')
plt.show()

# TSLA
pd.plotting.autocorrelation_plot(data['TSLA_DailyChange'])
plt.title('Partial Autocorrelation of TSLA on Daily Return')
plt.show()

#Autocorrelation on daily volatility

# GOOGL
plot_acf(data_vol_GOOGL, lags=20)
plt.title('Autocorrelation of GOOGL on Daily Volatility')
plt.show()

#MSFT
plot_acf(data_vol_MSFT, lags=20)
plt.title('Autocorrelation of MSFT on Daily Volatility')
plt.show()

#TLW.L
plot_acf(data_vol_TLW, lags=20)
plt.title('Autocorrelation of TLW on Daily Volatility')
plt.show()

#TSLA
plot_acf(data_vol_TSLA, lags=20)
plt.title('Autocorrelation of TSLA on Daily Volatility')
plt.show()

#Partial Autocorrelation on daily volatility

# GOOGL
pd.plotting.autocorrelation_plot(data_vol_GOOGL)
plt.title('Partial Autocorrelation of GOOGL on Daily Volatility')
plt.show()

# MSFT
pd.plotting.autocorrelation_plot(data_vol_MSFT)
plt.title('Partial Autocorrelation of MSFT on Daily Volatility')
plt.show()

# TLW.L
pd.plotting.autocorrelation_plot(data_vol_TLW)
plt.title('Partial Autocorrelation of TLW on Daily Volatility')
plt.show()

# TSLA
pd.plotting.autocorrelation_plot(data_vol_TSLA)
plt.title('Partial Autocorrelation of TSLA on Daily Volatility')
plt.show()

#downloading the data for each stock seperately in order for the values to unpack
df1 = yf.download('GOOGL', start='2020-03-15', end='2022-03-15')

y = df1['Adj Close']

from statsmodels.tsa.stattools import adfuller
result = adfuller(y)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

#Test for staionarity
def test_stationarity(timeseries):
    #Determing rolling statistics
    rolmean = timeseries.rolling(12).mean()
    rolstd = timeseries.rolling(12).std()
    #Plot rolling statistics:
    plt.plot(timeseries, color='blue',label='Original')
    plt.plot(rolmean, color='red', label='Rolling Mean')
    plt.plot(rolstd, color='black', label = 'Rolling Std')
    plt.legend(loc='best')
    plt.title('Rolling Mean and Standard Deviation')
    plt.rcParams["figure.figsize"] = (8,4)
    plt.show(block=False)
test_stationarity(y)

import statsmodels.api
import statsmodels as sm

res = sm.tsa.seasonal.seasonal_decompose(y, model='additive', freq=252)
plt.rcParams["figure.figsize"] = (10,6)

resplot = res.plot()

y_Seasonality=res.seasonal[res.seasonal.index.year == 2022]
MA1=y_Seasonality.rolling(window=20).mean()
plt.plot(y_Seasonality, label='GOOGL Seasonality')
plt.plot(MA1, label='20D MA')
plt.title("Seasonality of GOOGL", fontsize=18, fontweight='bold')
plt.legend()
plt.figure(figsize=(4,10))

plt.plot(y[y.index.year == 2022]+y_Seasonality,color='blue',label='Seasonality Adjusted GOOGl');
plt.plot(y[y.index.year == 2022],label='GOOGL')
plt.legend(loc=4)
plt.figure(figsize=(4,10))

plt.plot(y[y.index.year == 2020]+res.seasonal[res.seasonal.index.year == 2020],color='blue',label='Seasonality Adjusted GOOGL');
plt.plot(y[y.index.year == 2020],label='GOOGL')
plt.legend(loc=4)
plt.figure(figsize=(10,4))

df1['3day MA'] = df1['Adj Close'].shift(1).rolling(window=3).mean()
df1['10day MA'] = df1['Adj Close'].shift(1).rolling(window=10).mean()
df1['30day MA'] = df1['Adj Close'].shift(1).rolling(window=30).mean()
df1['Std_dev'] = df1['Adj Close'].rolling(5).std()
df1.describe()

# Let's see a historical view of the closing price
#We can see a significant upward trend here reflecting a 12-month price increase from 1728.239990 to 2673.810059  
df1['Adj Close'].plot(legend=True, figsize=(10,4))

df1[['Adj Close','3day MA','10day MA','30day MA']].plot(subplots=False,figsize=(10,4))

columns_multi = [x for x in list(df1.columns)]
columns_multi
plt.rcParams['figure.figsize'] = (10,20)
names = columns_multi
df1.hist(layout = (7,2), column = columns_multi)
plt.show()

names = columns_multi
df1.plot(kind='density', subplots=True, layout=(7,2), sharex=False)
plt.show()

df1 = yf.download('TSLA', start='2020-03-15', end='2022-03-15')
y = df1['Adj Close']

from statsmodels.tsa.stattools import adfuller
result = adfuller(y)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

#Test for stationarity
def test_stationarity(timeseries):
    #Determing rolling statistics
    rolmean = timeseries.rolling(12).mean()
    rolstd = timeseries.rolling(12).std()
    #Plot rolling statistics:
    plt.plot(timeseries, color='blue',label='Original')
    plt.plot(rolmean, color='red', label='Rolling Mean')
    plt.plot(rolstd, color='black', label = 'Rolling Std')
    plt.legend(loc='best')
    plt.title('Rolling Mean and Standard Deviation')
    plt.rcParams["figure.figsize"] = (8,4)
    plt.show(block=False)
test_stationarity(y)

import statsmodels.api
import statsmodels as sm

res = sm.tsa.seasonal.seasonal_decompose(y, model='additive', freq=252)
plt.rcParams["figure.figsize"] = (10,6)

resplot = res.plot()

y_Seasonality=res.seasonal[res.seasonal.index.year == 2022]
MA1=y_Seasonality.rolling(window=20).mean()
plt.plot(y_Seasonality, label='TSLA Seasonality')
plt.plot(MA1, label='20D MA')
plt.title("Seasonality of TSLA", fontsize=18, fontweight='bold')
plt.legend()
plt.figure(figsize=(4,10))

plt.plot(y[y.index.year == 2022]+y_Seasonality,color='blue',label='Seasonality Adjusted TSLA');
plt.plot(y[y.index.year == 2022],label='TSLA')
plt.legend(loc=4)
plt.figure(figsize=(10,4))

plt.plot(y[y.index.year == 2020]+res.seasonal[res.seasonal.index.year == 2020],color='blue',label='Seasonality Adjusted TSLA');
plt.plot(y[y.index.year == 2020],label='TSLA')
plt.legend(loc=4)
plt.figure(figsize=(10,4))

df1['3day MA'] = df1['Adj Close'].shift(1).rolling(window=3).mean()
df1['10day MA'] = df1['Adj Close'].shift(1).rolling(window=10).mean()
df1['30day MA'] = df1['Adj Close'].shift(1).rolling(window=30).mean()
df1['Std_dev'] = df1['Adj Close'].rolling(5).std()
df1.describe()

#Adjusred close price 
df1['Adj Close'].plot(legend=True, figsize=(10,4))

df1[['Adj Close','3day MA','10day MA','30day MA']].plot(subplots=False,figsize=(10,4))

columns_multi = [x for x in list(df1.columns)]
columns_multi
plt.rcParams['figure.figsize'] = (10,20)
names = columns_multi
df1.hist(layout = (7,2), column = columns_multi)
plt.show()

names = columns_multi
df1.plot(kind='density', subplots=True, layout=(7,2), sharex=False)
plt.show()

df1 = yf.download('MSFT', start='2020-03-15', end='2022-03-15')
y = df1['Adj Close']

from statsmodels.tsa.stattools import adfuller
result = adfuller(y)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

#Test for staionarity
def test_stationarity(timeseries):
    #Determing rolling statistics
    rolmean = timeseries.rolling(12).mean()
    rolstd = timeseries.rolling(12).std()
    #Plot rolling statistics:
    plt.plot(timeseries, color='blue',label='Original')
    plt.plot(rolmean, color='red', label='Rolling Mean')
    plt.plot(rolstd, color='black', label = 'Rolling Std')
    plt.legend(loc='best')
    plt.title('Rolling Mean and Standard Deviation')
    plt.rcParams["figure.figsize"] = (8,4)
    plt.show(block=False)
test_stationarity(y)

import statsmodels.api
import statsmodels as sm

res = sm.tsa.seasonal.seasonal_decompose(y, model='additive', freq=252)
plt.rcParams["figure.figsize"] = (10,6)

resplot = res.plot()

y_Seasonality=res.seasonal[res.seasonal.index.year == 2022]
MA1=y_Seasonality.rolling(window=20).mean()
plt.plot(y_Seasonality, label='MSFT Seasonality')
plt.plot(MA1, label='20D MA')
plt.title("Seasonality of MSFT", fontsize=18, fontweight='bold')
plt.legend()
plt.figure(figsize=(4,10))

plt.plot(y[y.index.year == 2022]+y_Seasonality,color='blue',label='Seasonality Adjusted MSFT');
plt.plot(y[y.index.year == 2022],label='MSFT')
plt.legend(loc=4)
plt.figure(figsize=(10,4))

plt.plot(y[y.index.year == 2020]+res.seasonal[res.seasonal.index.year == 2020],color='blue',label='Seasonality Adjusted MSFT');
plt.plot(y[y.index.year == 2020],label='MSFT')
plt.legend(loc=4)
plt.figure(figsize=(10,4))

df1['3day MA'] = df1['Adj Close'].shift(1).rolling(window=3).mean()
df1['10day MA'] = df1['Adj Close'].shift(1).rolling(window=10).mean()
df1['30day MA'] = df1['Adj Close'].shift(1).rolling(window=30).mean()
df1['Std_dev'] = df1['Adj Close'].rolling(5).std()
df1.describe()

df1['Adj Close'].plot(legend=True, figsize=(10,4))

df1[['Adj Close','3day MA','10day MA','30day MA']].plot(subplots=False,figsize=(10,4))

columns_multi = [x for x in list(df1.columns)]
columns_multi
plt.rcParams['figure.figsize'] = (10,20)
names = columns_multi
df1.hist(layout = (7,2), column = columns_multi)
plt.show()

names = columns_multi
df1.plot(kind='density', subplots=True, layout=(7,2), sharex=False)
plt.show()

df1 = yf.download('TWL.L', start='2020-03-15', end='2022-03-15')
y = df1['Adj Close']

from statsmodels.tsa.stattools import adfuller
result = adfuller(y)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

import statsmodels.api
import statsmodels as sm

res = sm.tsa.seasonal.seasonal_decompose(y, model='additive', freq=252)
plt.rcParams["figure.figsize"] = (10,6)

resplot = res.plot()